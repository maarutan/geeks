# Что такое инкапсуляция и как она реализована в Python?
# Ответ: Инкапсуляция скрывает детали реализации и защищает данные объекта от прямого изменения.
# В Python инкапсуляция реализована через приватные атрибуты и методы, которые обозначаются двумя подчёркиваниями.


class BankAccount:
    def __init__(self, initialBalance):
        self.__balance = initialBalance  # Приватный атрибут (инкапсуляция)

    def deposit(self, amount):
        # Приватный метод для изменения баланса
        self.__balance += amount

    def getBalance(self):
        # Метод для доступа к приватному атрибуту
        return self.__balance


# Пример использования инкапсуляции:
account = BankAccount(1000)
account.deposit(500)
print(account.getBalance())  # Ожидаемый результат: 1500


# Что такое наследование и как его использовать?
# Ответ: Наследование позволяет одному классу (дочернему) наследовать свойства и методы другого класса (родительского).
# Это позволяет переиспользовать код и расширять функциональность.


class Animal:
    def speak(self):
        return "I am an animal!"


class Dog(Animal):  # Наследование от класса Animal
    def speak(self):
        return "I am a dog!"


# Пример использования наследования:
dog = Dog()
print(dog.speak())  # Ожидаемый результат: "I am a dog!"


# Как работает инициализация объектов с помощью метода __init__?
# Ответ: Инициализация — это процесс создания и настройки объекта.
# В Python метод __init__ выполняется при создании объекта и позволяет задать начальные значения атрибутов.


class Person:
    def __init__(self, name, age):
        self.name = name  # Инициализация атрибутов объекта
        self.age = age


# Пример инициализации:
person = Person("Marat", 25)
print(person.name)  # Ожидаемый результат: "Marat"
print(person.age)  # Ожидаемый результат: 25


# Что такое множественное наследование и как работает super()?
# Ответ: Множественное наследование — это возможность наследовать от нескольких классов.
# Метод super() используется для вызова методов родительского класса, что особенно важно при работе с множественным наследованием.


class A:
    def __init__(self):
        print("Initializing A")


class B:
    def __init__(self):
        print("Initializing B")


class C(A, B):  # Множественное наследование
    def __init__(self):
        super().__init__()  # Вызов конструктора A через super()
        B.__init__(self)  # Явный вызов конструктора B
        print("Initializing C")


# Пример использования множественного наследования:
c = C()
# Ожидаемый результат:
# Initializing A
# Initializing B
# Initializing C


# Как установить пакет через pip и использовать его в Python?
# Ответ: pip — это менеджер пакетов в Python, который позволяет устанавливать сторонние библиотеки.
# Он автоматически загружает и устанавливает нужные библиотеки, упрощая работу с внешними зависимостями.

# Пример установки пакета (в терминале):
# pip install requests

import requests  # Пример использования установленного пакета requests

response = requests.get("https://api.github.com")
print(response.status_code)  # Ожидаемый результат: 200, если запрос успешен


# Как Python обрабатывает множественное наследование и как работает порядок разрешения методов (MRO)?
# Ответ: MRO (Method Resolution Order) — это порядок, в котором Python ищет методы при множественном наследовании.
# MRO помогает разрешить конфликты между классами, определяя, какой метод будет вызван первым.
# Python использует алгоритм C3 Linearization для определения MRO.


class X:
    def action(self):
        return "Action from X"


class Y:
    def action(self):
        return "Action from Y"


class Z(X, Y):  # Множественное наследование
    pass


z = Z()
print(
    z.action()
)  # Ожидаемый результат: "Action from X", так как X стоит первым в порядке наследования

# Проверим порядок разрешения методов:
print(Z.mro())
# Ожидаемый результат: [<class '__main__.Z'>, <class '__main__.X'>, <class '__main__.Y'>, <class 'object'>]
